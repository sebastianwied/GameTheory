#include <iostream>
#include <string>
#include <vector>
#include <random>

using namespace std;
#define DEF 0
#define COOP 1
#define T 5
#define R 3
#define P 1
#define S 0

class Agent {
    public:
        Agent();
        string agType;
        string repr() { return "Score: " + to_string(points); }
        int prev;

    friend class Arbiter;

    friend void playNIterations(int n, Agent* a1, Agent* a2) {
        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<> dis(0.0, 1.0);

        for (int i = 0; i < n; ++i) {
            int move = getMove(dis(gen), dis(gen), a1, a2);
            distributeScore(a1, a2, move);
        }
    }

    friend int getMove(float seed1, float seed2, Agent* ag1, Agent* ag2) {
        int ag1move = ag1->playMove(seed1, ag2->prev);
        int ag2move = ag2->playMove(seed2, ag1->prev);
        int move = ag1move + (2*ag2move);
        // move key:
        // a1 controls whether +1(coop) or +0(def)
        // a2 controls whether +2(coop) or +0(def)
        // a1 def, a2 def = 0
        // a1 coop, a2 def = 1
        // a1 def, a2 coop = 2
        // a1 coop, a2 coop = 3
        return move;
    }

    friend void distributeScore(Agent* ag1, Agent* ag2, int move) {
        switch (move) {
            case 0:
                ag1->addPoints(P);
                ag2->addPoints(P);
                break;
            case 1:
                ag1->addPoints(S);
                ag2->addPoints(T);
                break;
            case 2:
                ag1->addPoints(T);
                ag2->addPoints(S);
                break;
            case 3:
                ag1->addPoints(R);
                ag2->addPoints(R);
                break;    
        }
    }

    vector<float> rule; // memory-one strategy
    int points = 0; // score for this round(round != iteration!)
    int turnOne; // first played move, some strategies have a special start

    Agent(int type) {
        switch (type) {
            case 0:
                rule = std::vector<float>{1.0, 1.0, 1.0, 1.0};
                agType = "CU";
                turnOne = COOP;
                prev = COOP;
                break;
            case 1:
                rule = std::vector<float>{0.0, 0.0, 0.0, 0.0};
                agType = "DU";
                turnOne = COOP;
                prev = DEF;
                break;
            case 2:
                rule = std::vector<float>{0.0, 1.0, 0.0, 1.0};
                agType = "TFT";
                turnOne = COOP;
                prev = COOP;
                break;
            default:
                rule = std::vector<float>{0.5, 0.5, 0.5, 0.5};
                agType = "RAND";
                turnOne = COOP;
                prev = COOP;
                break;
        }
    }
    void setPoints(int newPoints) {
        points = newPoints;
    }
    void addPoints(int newPoints) {
        points += newPoints;
        return;
    }
    int playMove(float seed, int themPrev) {
        float prob = rule[(prev*2)+themPrev];
        //cout << "Prob: " << to_string(prob) << endl;
        if (seed < prob) { 
            prev = COOP;
            return COOP; 
        }
        prev = DEF;
        return DEF;
    }
};

int main() {
    Agent ag1 = Agent(3);
    Agent ag2 = Agent(3);
    playNIterations(100, &ag1, &ag2);
    cout << ag1.repr() << "   " << ag2.repr() << endl;
    return 0;
}
